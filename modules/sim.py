from matplotlib import projections
import tensorflow as tf
import numpy as np 
import time
import pandas as pd
import utility as ut
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

DTYPE = 'float64'


class Grid:
    """
    A class for collecting grid data for MC simulation

    Attributes:
        dim: dimension of the grid
        mins: array of lower bounds for the grid
        maxs: array of upper bounds for the grid 
        h: array of step sizes in every dimension 
        dV: volume of smallest cube in the grid
    """
    def __init__(self, dim):
        self.dim = dim
        self.mins = np.zeros(dim)
        self.maxs = np.zeros(dim) 
        self.h = np.zeros(dim)
        self.dV = np.prod(self.h)


class MCProb:
    """
    A class for computing Monte Carlo estimate of 2d densities with 
    the SDE of the form dX_t = mu(X_t)dt + sigma x dW_t

    Attributes:
        mu: drift in the the SDE 
        sigma: constant diffusion in the SDE 
        X0: initial ensemble 
        save_folder: folder to save the generated data
    """
    def __init__(self, save_folder, n_subdivs, mu=None, sigma=None, X0=None):
        self.X = X0 
        self.mu = mu 
        self.sigma = sigma
        self.save_folder = save_folder
        self.n_subdivs = n_subdivs
        self.n_particles = len(X0)
        self.dim = X0.shape[-1]
        self.grid = Grid(dim=self.dim)
        self.total_sims = self.n_particles

    @ut.timer
    def propagate(self, n_steps, dt):
        """
        Description: propagates particles according to the SDE and stores the final positions

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
        """
        self.final_time = dt * n_steps
        self.n_steps = n_steps
        start = time.time()
        for step in range(n_steps):
            self.X +=  self.mu(self.X) * dt + self.sigma * np.random.normal(scale=np.sqrt(dt), size=(self.n_particles, self.dim))
            if step%1000 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')
        pd.DataFrame(self.X).to_csv('{}/ensemble.csv'.format(self.save_folder), index=None, header=None)


    def roundup(self, real, n):
        """
        Description: Rounds up a real number to desired number of decimal points

        Args:
            real: a real number to round
            n: required number of decimal points
        """
        real *= 10.**n 
        return np.ceil(real) / (10.**n)
    
    @ut.timer
    def set_grid(self, lims=None):
        """
        Description: Computes shape of the grid generated by the propagation
        """
        pts = np.genfromtxt('{}/ensemble.csv'.format(self.save_folder), delimiter=',')
        if lims is None:
            for d in range(self.dim):
                self.grid.mins[d], self.grid.maxs[d] = self.roundup(min(pts[:, d]), 2), self.roundup(max(pts[:, d]), 2)
            min_max = np.array(list(zip(self.grid.mins, self.grid.maxs)))
        else:
            min_max = np.array(lims).T
            new_pts = []
            for pt in pts:
                a = pt - min_max.T[0]
                b = min_max.T[1] - pt 
                c = a * b
                if c[0] > 0. and c[1] > 0. and c[2] > 0.:
                    new_pts.append(pt) 
            pd.DataFrame(np.array(new_pts)).to_csv('{}/ensemble.csv'.format(self.save_folder), index=None, header=None)
        pd.DataFrame(min_max).to_csv('{}/min_max.csv'.format(self.save_folder), index=None, header=None)


    def get_grid(self):
        """
        Description: Reads pre-computed grid 
        """
        min_max = np.genfromtxt('{}/min_max.csv'.format(self.save_folder), delimiter=',')
        for d in range(self.dim):
            self.grid.mins[d], self.grid.maxs[d] = min_max[d]
        
        self.grid.h = (self.grid.maxs - self.grid.mins) / self.n_subdivs
        self.grid.dV = np.prod(self.grid.h)
        return self.grid


    @ut.timer
    def assign_pts(self):
        """
        Description: Assigns the generated points to the grid boxes
        """
        pts = np.genfromtxt('{}/ensemble.csv'.format(self.save_folder), delimiter=',')
        self.get_grid()
        coords = ((pts - self.grid.mins) / self.grid.h).astype(int)
        pd.DataFrame(coords).to_csv('{}/coordinates.csv'.format(self.save_folder), index=None, header=None)

    
    @ut.timer
    def compute_pd(self):
        """
        Description: Computes probability in each box in the grid
        """
        coords = np.genfromtxt('{}/coordinates.csv'.format(self.save_folder), delimiter=',')
        boxes, counts = np.unique(coords, return_counts=True, axis=0)
        
        pd.DataFrame(boxes).to_csv('{}/boxes.csv'.format(self.save_folder), index=None, header=None)
        pd.DataFrame(counts).to_csv('{}/counts.csv'.format(self.save_folder), index=None, header=None)

        self.get_grid()
        centers = self.grid.mins + boxes * self.grid.h + self.grid.h / 2.
        probs = counts / self.total_sims
        idx = np.argsort(probs)

        pd.DataFrame(centers[idx][::-1]).to_csv('{}/centers.csv'.format(self.save_folder), index=None, header=None)
        pd.DataFrame(probs[idx][::-1]).to_csv('{}/center_probs.csv'.format(self.save_folder), index=None, header=None)


    @ut.timer
    def compute_p2(self, i, j):
        """
        Description: Computes probability in each box in a two-dimensional grid

        Args:
            i: index specifying the first dimension
            j: index specifying the second dimension
        """
        coords = np.genfromtxt('{}/coordinates.csv'.format(self.save_folder), delimiter=',')
        boxes, counts = np.unique(coords[:, [i, j]], return_counts=True, axis=0)
        pd.DataFrame(boxes).to_csv('{}/boxes_{}_{}.csv'.format(self.save_folder, i, j), index=None, header=None)
        pd.DataFrame(counts).to_csv('{}/counts_{}_{}.csv'.format(self.save_folder, i, j), index=None, header=None)

        self.get_grid()
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs)
        prob = np.zeros((self.n_subdivs, self.n_subdivs))
        
        for k, b in enumerate(boxes):
            prob[int(b[0]), int(b[1])] = counts[k] 

        prob /= np.sum(prob)
        x, y = np.meshgrid(x, y)
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, prob, cmap='inferno', shading='auto')
        fig.colorbar(im)
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'MC estimate of $p(x_{}, x_{})$ at time = {:.4f}'.format(i, j, self.final_time))
        plt.tight_layout()
        plt.savefig('{}/p_{}_{}_mc_steps_{}.png'.format(self.save_folder, i, j, self.n_steps))
        plt.close(fig)


    @ut.timer
    def compute_p1(self, i):
        """
        Description: Computes probability in each interval in a one-dimensional grid

        Args:
            i: index specifying the dimension
        """
        coords = np.genfromtxt('{}/coordinates.csv'.format(self.save_folder), delimiter=',')
        boxes, counts = np.unique(coords[:, i], return_counts=True, axis=0)
        pd.DataFrame(boxes).to_csv('{}/boxes_{}.csv'.format(self.save_folder, i), index=None, header=None)
        pd.DataFrame(counts).to_csv('{}/counts_{}.csv'.format(self.save_folder, i), index=None, header=None)

        self.get_grid()
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs)
        prob = np.zeros(self.n_subdivs)
        for k, b in enumerate(boxes):
            prob[int(b)] = counts[k]

        prob /= np.sum(prob)
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        ax.plot(x, prob)
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$p(x_{})$'.format(i))
        ax.set_title(r'MC estimate of $p(x_{})$ at time = {:.4f}'.format(i, self.final_time))
        plt.tight_layout()
        plt.savefig('{}/p_{}_mc_steps_{}.png'.format(self.save_folder, i, self.n_steps))
        plt.close(fig) 
    

    @ut.timer
    def ready(self, n_steps, dt, lims=None):
        self.propagate(n_steps, dt)
        self.set_grid(lims)
        self.assign_pts()

    @ut.timer
    def compute_all(self, n_steps, dt, lims=None):
        """
        Description: Computes all d, 2 and 1 dimensional densities

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
        """
        self.ready(n_steps, dt, lims=None)
        self.compute_pd()
        for i in range(self.dim):
            self.compute_p1(i)
            for j in range(i+1, self.dim):
                self.compute_p2(i, j)



    @ut.timer
    def get_slice_pts(self, dims=[0, 1], levels={2: 0.}, eps=0.1):
        pts = np.genfromtxt('{}/ensemble.csv'.format(self.save_folder), delimiter=',')
        for i in levels:
            idx = np.where(pts[:, i] < levels[i] + eps)[0]
            pts = pts[idx, :]
            idx = np.where(pts[:, i] > levels[i] - eps)[0]
            pts = pts[idx, :]
        return pts 

    @ut.timer
    def slice2D(self, dims=[0, 1], levels={2: 0.}, eps=0.1):
        """
        Description: Computes probability on a 2D slice

        Args:
            dims: indices specifying the 2D slice
            levels: values of rest of the dimensions 
            eps: leeway in the rest of the dimensions
        """
        pts = self.get_slice_pts(dims, levels, eps)
        self.get_grid()
        i, j = sorted(dims)
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs)
        prob = np.zeros((self.n_subdivs, self.n_subdivs))
        coords = ((pts - self.grid.mins) / self.grid.h).astype(int)
        boxes, counts = np.unique(coords[:, [i, j]], return_counts=True, axis=0)
        

        for k, b in enumerate(boxes):
            prob[int(b[0]), int(b[1])] = counts[k] 

        prob /= np.sum(prob)
        x, y = np.meshgrid(x, y)
        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, prob, cmap='inferno', shading='auto')
        fig.colorbar(im)
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'MC estimate of $p(x_{}, x_{})$ at time = {:.4f}'.format(i, j, self.final_time))
        plt.tight_layout()
        plt.savefig('{}/p_slice_{}_{}_mc_steps_{}.png'.format(self.save_folder, i, j, self.n_steps))
        plt.close(fig)



class FKSimGrid3_2:
    """
    Description: Feynman-Kac simulation for a 2D grid taking integration 
    in the other dimension into consideration
    """
    def __init__(self, save_folder, n_subdivs, n_int_subdivs, mu, sigma, n_theta, grid,\
                h0, dtype='float32') -> None:
        self.grid = grid 
        self.mu = mu 
        self.sigma = sigma
        self.n_theta = n_theta
        self.n_subdivs = n_subdivs
        self.n_int_subdivs = n_int_subdivs         
        self.h0 = h0
        self.dtype = dtype
        self.save_folder = save_folder
        self.dim = 3

        

    @ut.timer
    def propagate(self, n_steps, dt, n_repeats, k, gq=False, replace=100.):
        """
        Description: propagates particles according to the SDE and stores the final positions

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
            n_repeats: number of simulations per grid point
            k: index specifying the dimension to integrate along
            gq: boolean flag for using Gauss quadrature
        """
        i, j = set(range(3)) - {k}
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs).astype(self.dtype)
        if not gq:
            z = np.linspace(self.grid.mins[k], self.grid.maxs[k], num=self.n_int_subdivs + 1).astype(self.dtype)
        else:
            gq = np.genfromtxt('{}/gq_{}.csv'.format(self.save_folder, self.n_int_subdivs), delimiter=',').astype(self.dtype)
            a, b = self.grid.mins[k], self.grid.maxs[k]
            z = (gq[:, 1] * (b - a) + (b + a)) / 2.

        z, x, y = np.meshgrid(z, x, y, indexing='ij')
        x = x.reshape(-1, 1)
        y = y.reshape(-1, 1)
        z = z.reshape(-1, 1)

        X0 = tf.concat([e for _, e in sorted(zip([i, j, k], [x, y, z]))], axis=-1)
        X = tf.repeat(X0, n_repeats, axis=0)
        n_particles = len(X)
        self.n_steps = n_steps
        self.final_time = dt * n_steps


        start = time.time()
        for step in range(n_steps):
            X +=  self.mu(X) * dt + self.sigma * np.random.normal(scale=np.sqrt(dt), size=(n_particles, self.dim))
            if step%1 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')

        X = np.nan_to_num(X.numpy(), nan=replace, posinf=replace, neginf=replace)
        X0 = X0.numpy()
        print(X)
        # save data
        q = n_repeats * self.n_subdivs * self.n_subdivs
        l = self.n_subdivs * self.n_subdivs
        letters = ['x', 'y', 'z']
        for n in range(self.n_int_subdivs + 1):
            pd.DataFrame(X0[n*l: (n+1)*l, :]).to_csv('{}/{}{}0_{}.csv'.format(self.save_folder, i, j, n), index=None, header=None)
            pd.DataFrame(X[n*q: (n+1)*q, :]).to_csv('{}/{}{}T_{}_rep_{}_steps_{}.csv'.format(self.save_folder, i, j, n, n_repeats, n_steps), index=None, header=None)
    
    

    @ut.timer
    def compile(self, n_repeats, k, gq=False, replace=0.):
        i, j = set(range(3)) - {k}
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs).astype(self.dtype)
        x, y = np.meshgrid(x, y)
        x = x.reshape(-1, 1)
        y = y.reshape(-1, 1)
     
        n_particles = self.n_subdivs * self.n_subdivs
        if not gq:
            Z = np.linspace(self.grid.mins[k], self.grid.maxs[k], num=self.n_int_subdivs + 1).astype(self.dtype)
            w = np.array([2. if i%2==0 else 4. for i in range(self.n_int_subdivs + 1)])
            w[0] = w[-1] = 1.
            w *=  (self.grid.maxs[k] - self.grid.mins[k]) / (3. * self.n_int_subdivs)
        else:
            gq = np.genfromtxt('{}/gq_{}.csv'.format(self.save_folder, self.n_int_subdivs), delimiter=',').astype(self.dtype)
            a, b = self.grid.mins[k], self.grid.maxs[k]
            Z = (gq[:, 1] * (b - a) + (b + a)) / 2.
            w = gq[:, 0]
            w *= (self.grid.h[i] * self.grid.h[j]) * (self.grid.maxs[k] - self.grid.mins[k]) / 2.
        
        p = np.zeros(n_particles)
        letters = ['x', 'y', 'z']
        start = time.time()
        for l, z in enumerate(np.linspace(self.grid.mins[k], self.grid.maxs[k], num=self.n_int_subdivs + 1).astype(self.dtype)):
            z = z * np.ones_like(x)
            X = np.genfromtxt('{}/{}{}T_{}_rep_{}_steps_{}.csv'.format(self.save_folder, i, j, l, n_repeats, self.n_steps), delimiter=',', dtype=self.dtype)
            # X = tf.convert_to_tensor(X)
            #print("------------->shape of X = {}<---------------".format(X.shape))
            h0 = np.nan_to_num(self.h0(X).reshape((n_particles, n_repeats)), nan=replace, posinf=replace, neginf=replace)
            h = np.sum(h0, axis=-1) / n_repeats
            X0 = np.genfromtxt('{}/{}{}0_{}.csv'.format(self.save_folder, i, j, l), delimiter=',', dtype=self.dtype)
            p_inf = tf.exp(self.n_theta(*tf.split(X0, X0.shape[-1], axis=-1))).numpy().flatten()
            p_ = h * p_inf
            # save data
            pd.DataFrame(p_).to_csv('{}/p_{}_{}_{}.csv'.format(self.save_folder, i, j, l), index=None, header=None)
            print('z count = {}, time taken = {:.4f}'.format(i, time.time() - start), end='\r')
            p += w[l] * p_   
        if p.sum() > 0.:
            p /= p.sum()
        pd.DataFrame(p).to_csv('{}/p_{}_{}.csv'.format(self.save_folder, i, j), index=None, header=None)

        grid = (self.n_subdivs, self.n_subdivs)
        x = x.reshape(grid)
        y = y.reshape(grid)
        p = p.reshape(grid)

        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, p, cmap='inferno', shading='auto')
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'$p(x_{}, x_{})$ at time = {:.4f}'.format(i, j, self.final_time))
        fig.colorbar(im)
        plt.savefig('{}/p_{}_{}_steps_{}.png'.format(self.save_folder, i, j, self.n_steps))

    @ut.timer
    def propagate_and_compile(self, n_steps, dt, n_repeats, k, gq=False, replace=100.):
        self.propagate(n_steps, dt, n_repeats, k, gq, replace)
        self.compile(n_repeats, k, gq)

    @ut.timer
    def compute_all(self, n_steps, dt, n_repeats, gq=False, replace=100.):
        for k in range(3):
            self.propagate_and_compile(n_steps, dt, n_repeats, k, gq, replace)


    def plot3d(self, idx, rest_values=[]):
        self.dim = len(idx) + len(rest_values)
        i, j = idx
        rest = set(range(self.dim)) - {i, j}
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs).astype(self.dtype)
        p = np.genfromtxt('{}/p_{}_{}.csv'.format(self.save_folder, i, j), delimiter=',')
        
        grid = (self.n_subdivs, self.n_subdivs)
        x = x.reshape(grid)
        y = y.reshape(grid)
        p = p.reshape(grid)

        
        if rest_values is not None:
            word = ''
            k = 0
            for d in range(self.dim):
                if d in rest:
                    word += r'$x_{}={}$'.format(d, rest_values[k])
                    k += 1
                else:
                    word += r'$x_{}$'.format(d)
                if d < self.dim - 1:
                    word += ', '
        else:
            word = r'$x_{}, x_{}$'.format(*sorted(idx))


        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.plot_surface(x, y, p, cmap='inferno')
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_zlabel('p({})'.format(word))
        fig.colorbar(im)
        plt.savefig('{}/p_{}_{}.png'.format(self.save_folder, i, j))






class FKSimGrid2:
    """
    Description: Feynman-Kac simulation for a 2D grid taking integration 
    in the other dimension into consideration
    """
    def __init__(self, save_folder, n_subdivs, mu, sigma, n_theta, grid,\
                h0, dtype='float32') -> None:
        self.grid = grid 
        self.mu = mu 
        self.sigma = sigma
        self.n_theta = n_theta
        self.n_subdivs = n_subdivs       
        self.h0 = h0
        self.dtype = dtype
        self.save_folder = save_folder
        self.dim = 2

        

    @ut.timer
    def propagate(self, n_steps, dt, n_repeats):
        """
        Description: propagates particles according to the SDE and stores the final positions

        Args:
            n_steps: number of steps in Euler-Maruyama
            dt: time-step in Euler-Maruyama
            n_repeats: number of simulations per grid point
            k: index specifying the dimension to integrate along
            gq: boolean flag for using Gauss quadrature
        """
        i, j = 0, 1
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs).astype(self.dtype)

        x, y = np.meshgrid(x, y, indexing='ij')
        x = x.reshape(-1, 1)
        y = y.reshape(-1, 1)
        

        X0 = tf.concat([x, y], axis=-1)
        self.dim = X0.shape[-1]
        X = tf.repeat(X0, n_repeats, axis=0)
        n_particles = len(X)
        self.n_steps = n_steps
        self.final_time = dt * n_steps


        start = time.time()
        for step in range(n_steps):
            X +=  self.mu(X) * dt + self.sigma * np.random.normal(scale=np.sqrt(dt), size=(n_particles, self.dim))
            if step%1 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')

        X = X.numpy()
        X0 = X0.numpy()
        # save data
        pd.DataFrame(X0).to_csv('{}/{}{}0.csv'.format(self.save_folder, i, j), index=None, header=None)
        pd.DataFrame(X).to_csv('{}/{}{}T_rep_{}_steps_{}.csv'.format(self.save_folder, i, j, n_repeats, n_steps), index=None, header=None)
    
    

    @ut.timer
    def compile(self, n_repeats):
        i, j = 0, 1
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs).astype(self.dtype)
        x, y = np.meshgrid(x, y)
        x = x.reshape(-1, 1)
        y = y.reshape(-1, 1)
     
        n_particles = self.n_subdivs * self.n_subdivs
        
        p = np.zeros(n_particles)
        start = time.time()
        
     
        X = np.genfromtxt('{}/{}{}T_rep_{}_steps_{}.csv'.format(self.save_folder, i, j, n_repeats, self.n_steps), delimiter=',', dtype=self.dtype)
        h = np.sum(self.h0(X).reshape((n_particles, n_repeats)), axis=-1) / n_repeats
        X0 = np.genfromtxt('{}/{}{}0.csv'.format(self.save_folder, i, j), delimiter=',', dtype=self.dtype)
        p_inf = tf.exp(self.n_theta(*tf.split(X0, X0.shape[-1], axis=-1))).numpy().flatten()
        p = h * p_inf
        print(h)
        print(np.mean((tf.reduce_sum(X0**2, axis=-1)-1.)**2))
        print(np.mean(p_inf))
        print(p)
        p /= p.sum()
        pd.DataFrame(p).to_csv('{}/p_{}_{}.csv'.format(self.save_folder, i, j), index=None, header=None)

        grid = (self.n_subdivs, self.n_subdivs)
        x = x.reshape(grid)
        y = y.reshape(grid)
        p = p.reshape(grid)

        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, p, cmap='inferno', shading='auto')
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'$p(x_{}, x_{})$ at time = {:.4f}'.format(i, j, self.final_time))
        fig.colorbar(im)
        plt.savefig('{}/p_{}_{}_steps_{}.png'.format(self.save_folder, i, j, self.n_steps))

    @ut.timer
    def propagate_and_compile(self, n_steps, dt, n_repeats):
        self.propagate(n_steps, dt, n_repeats)
        self.compile(n_repeats)


    def plot3d(self, rest_values=[]):
        i, j = 0, 1
        rest = set(range(self.dim)) - {i, j}
        x = np.linspace(self.grid.mins[i], self.grid.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.grid.mins[j], self.grid.maxs[j], num=self.n_subdivs).astype(self.dtype)
        x, y = np.meshgrid(x, y)
    
        p = np.genfromtxt('{}/p_{}_{}.csv'.format(self.save_folder, i, j), delimiter=',')
        
        grid = (self.n_subdivs, self.n_subdivs)
        x = x.reshape(grid)
        y = y.reshape(grid)
        p = p.reshape(grid)

        
        if rest_values is not None:
            word = ''
            k = 0
            for d in range(self.dim):
                if d in rest:
                    word += r'$x_{}={}$'.format(d, rest_values[k])
                    k += 1
                else:
                    word += r'$x_{}$'.format(d)
                if d < self.dim - 1:
                    word += ', '
        else:
            word = r'$x_{}, x_{}$'.format(0, 1)


        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111, projection='3d')
        im = ax.plot_surface(x, y, p, cmap='inferno')
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_zlabel('p({})'.format(word))
        #fig.colorbar(im)
        plt.savefig('{}/p_{}_{}.png'.format(self.save_folder, i, j))



class Net2Net:
    """
    Class for interpolating a solution as a network from the steady-state network
    """
    def __init__(self, mu, sigma, t, n_steps, dt, X0, n_repeats, save_folder):
        self.mu = mu
        self.sigma = sigma
        self.t = t 
        self.save_folder = save_folder
        self.n_steps = n_steps
        self.dt = dt
        self.X0 = X0
        self.n_repeats = n_repeats
        self.dim = X0.shape[-1]
        self.n_particles = X0.shape[0]

    @ut.timer
    def propagate(self):
        X = tf.repeat(self.X0, self.n_repeats, axis=0)
        pd.DataFrame(self.X0.numpy()).to_csv('{}/random_starting_points.csv'.format(self.save_folder), index=None, header=None)
        start = time.time()
        for step in range(self.n_steps):
            dW = np.random.normal(scale=np.sqrt(self.dt), size=(self.n_particles * self.n_repeats, self.dim)).astype(DTYPE)
            X += self.mu(X) * self.dt + self.sigma * dW
            if step%10 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')
        pd.DataFrame(X.numpy()).to_csv('{}/ending_points_at_{}.csv'.format(self.save_folder, self.t), index=None, header=None)

    
    @ut.timer
    def gen_prob(self, log_p_inf, h0):
        X = np.genfromtxt('{}/ending_points_at_{}.csv'.format(self.save_folder, self.t), delimiter=',').astype(DTYPE)
        X0 = np.genfromtxt('{}/random_starting_points.csv'.format(self.save_folder), delimiter=',').astype(DTYPE)
        h = np.sum(h0(X).reshape((self.n_particles, self.n_repeats)), axis=-1) / self.n_repeats
        p_inf = tf.exp(log_p_inf(*tf.split(X0, X0.shape[-1], axis=-1))).numpy().flatten()
        p = h.flatten() * p_inf
        pd.DataFrame(p).to_csv('{}/prob_at_{}.csv'.format(self.save_folder, self.t), index=None, header=None)   
    

    def loss(self, net, x, y):
        return tf.reduce_mean((net(*tf.split(x, self.dim, axis=-1)) - y)**2)

    @tf.function
    def train_step(self, optimizer, net, x, y):
        with tf.GradientTape() as tape:
            L = self.loss(net, x, y)
        grads = tape.gradient(L, net.trainable_weights)
        optimizer.apply_gradients(zip(grads, net.trainable_weights))
        return L        


    @ut.timer
    def interpolate(self, net, X, p, epochs, batch_size=1000):
        # p_ = p.flatten()
        # self.mean = np.mean(p_)
        # self.std = np.std(p_)
        # p = (p_ - self.mean) / self.std
        p = p.reshape(-1, 1)
        data = tf.data.Dataset.from_tensor_slices((X, p))
        data = iter(data.shuffle(buffer_size=len(p)).cache().repeat().batch(batch_size).prefetch(tf.data.experimental.AUTOTUNE))
        
        idx = np.random.choice(len(p), replace=False, size=batch_size)
        X0, p0 = X[idx], p[idx]
        X, p = data.get_next()
        learning_rate = tf.keras.optimizers.schedules.PiecewiseConstantDecay([1000, 2000, 10000], [1e-2, 5e-3, 1e-3, 1e-3])
        optimizer = tf.keras.optimizers.Adam(learning_rate)
        print("{:>6}{:>12}{:>18}".format('Epoch', 'Loss', 'Runtime(s)'))
        start = time.time()
        for epoch in range(epochs):
            L = self.train_step(optimizer, net, X, p)
            if epoch % 10 == 0:
                print('{:6d}{:12.6f}{:18.4f}'.format(epoch, L, time.time()-start))
            if epoch % 100 == 0 and L.numpy() < 0.05:
                #idx = np.random.choice(len(p), replace=False, size=batch_size)
                X, p = data.get_next()
        net.save_weights('{}/interpolation_at_{}'.format(self.save_folder, self.t))


    @ut.timer
    def verify(self, net, mins, maxs, n_subdivs, n_int_subdivs, exp=False):
        plotter = PlotNet3_2(net, mins, maxs, n_subdivs, n_int_subdivs, exp, self.save_folder)
        plotter.plot_all(tag='interpolation_at_{}'.format(self.t))

    @ut.timer
    def project(self, net, mins, maxs, k, n_subdivs):
        self.n_subdivs = n_subdivs
        self.mins = mins 
        self.maxs = maxs
        i, j = set(range(3)) - {k}
        X = np.linspace(start=self.mins[i], stop=self.maxs[i], num=self.n_subdivs)
        Y = np.linspace(start=self.mins[j], stop=self.maxs[j], num=self.n_subdivs)
        Z = np.linspace(start=self.mins[k], stop=self.maxs[k], num=self.n_subdivs).reshape(-1, 1)
        
        p = np.zeros((self.n_subdivs, self.n_subdivs))
        w = np.array([2. if i%2==0 else 4. for i in range(self.n_subdivs)])
        w[0] = w[-1] = 1.
        for l, x in enumerate(X):
            for m, y in enumerate(Y):
                x = x * np.ones_like(Z)
                y = y * np.ones_like(Z)
                args = [e for _, e in sorted(zip([i, j, k], [x, y, Z]))]
                v = (net(*args).numpy().flatten()) 
                p[l, m] = np.sum(v * w)
        
        p /= p.sum()
        grid = (self.n_subdivs, self.n_subdivs)
        X, Y = np.meshgrid(X, Y)
        X = X.reshape(grid)
        Y = Y.reshape(grid)
        p = p.reshape(grid)

        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(X, Y, p, cmap='inferno', shading='auto')
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'$p(x_{}, x_{})$ at time = {:.4f}'.format(i, j, self.t))
        fig.colorbar(im)
        plt.savefig('{}/interpolated_prob_{}_{}_res_{}.png'.format(self.save_folder, i, j, self.n_subdivs))



class Evolution:
    """
    Class for visualizing evolution of an SDE
    """

    def __init__(self, save_folder, mu, sigma) -> None:
        self.mu = mu 
        self.sigma = sigma
        self.save_folder = save_folder

    @ut.timer
    def propagate(self, n_steps, dt, X0):
        self.dt = dt
        self.dim = X0.shape[-1]
        self.n_particles = X0.shape[0]
        self.X = np.zeros((n_steps + 1, self.n_particles, self.dim)).astype(DTYPE)
        self.X[0, :, :] = X0
        dW = np.random.normal(scale=np.sqrt(dt), size=(n_steps, self.n_particles, self.dim)).astype(DTYPE)
        start = time.time()
        for step in range(n_steps):
            self.X[step+1, :, :] = self.X[step, :, :] + self.mu(self.X[step, :, :]) * dt + self.sigma * dW[step, :, :]
            if step%1000 == 0:
                print('step = {}, time taken = {:.4f}'.format(step, time.time() - start), end='\r')
        np.save('{}/evolution.npy'.format(self.save_folder), self.X)


    def final_state(self, idx=[0, 1, 2]):
        """
        Description:
            Animates evolution of an ensemble
        
        Args:
            idx: dimensions to plot
        """
        fig = plt.figure(figsize=(8, 8))
        if len(idx) > 2:
            ax = fig.add_subplot(111, projection='3d')
            p, q, r = idx[:3]
            ax.scatter(self.X[-1, :, p], self.X[-1, :, q], self.X[-1, :, r])
            ax.set_xlabel(r'$x_{}$'.format(p))
            ax.set_ylabel(r'$x_{}$'.format(q))
            ax.set_zlabel(r'$x_{}$'.format(r))
        else:
            ax = fig.add_subplot(111)
            p, q = idx[:2]
            ax.scatter(self.X[-1, :, p], self.X[-1, :, q])
            ax.set_xlabel(r'$x_{}$'.format(p))
            ax.set_ylabel(r'$x_{}$'.format(q))
        
        ax.set_title('time = {:.3f}'.format((len(self.X) - 1) * self.dt))
        plt.savefig(self.save_folder + '/final_state.png')
        

    @ut.timer
    def animate(self, idx=[0, 1, 2], n_frames=100, max_pts=500):
        """
        Description:
            Animates evolution of an ensemble
        
        Args:
            idx: dimensions to plot
            n_frames: number of frames to plot
        """
        fig = plt.figure(figsize=(8, 8))
        if len(idx) > 2:
            ax = fig.add_subplot(111, projection='3d')
            p, q, r = idx[:3]
        else:
            ax = fig.add_subplot(111)
            p, q = idx[:2]

        n_pts = min(self.X.shape[1], max_pts)
        def animator(j):
            ax.clear()
            if len(idx) > 2:
                ax.scatter(self.X[j, :n_pts, p], self.X[j, :n_pts, q], self.X[j, :n_pts, r])
            else:
                ax.scatter(self.X[j, :n_pts, p], self.X[j, :n_pts, q])
            ax.set_title('time = {:.3f}'.format(j * self.dt))

        a = int(self.X.shape[0] / n_frames)
        frames = [f for f in range(self.X.shape[0]) if f%a == 0]
        animation = FuncAnimation(fig=fig, func=animator, frames = frames, interval=50, repeat=False)
        animation.save(self.save_folder + '/evolution.mp4', writer='ffmpeg')

    
    
    def exit_prob(self, domain):
        # check if pints are in the domain
        io = tf.greater((self.X - domain[0]) * (domain[1] - self.X), 0.)
        io = tf.math.reduce_all(io, axis=-1)
        # count points in the domain
        io = np.cumprod(io, axis=0)
        io = np.sum(io, axis=-1) / self.X.shape[1]
     

        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        t = [e*self.dt for e in range(len(io))]
        ax.plot(t, 1.0 - io)
        ax.set_ylabel('exit probability')
        ax.set_xlabel('time')
        plt.savefig(self.save_folder + '/exit_prob.png')
        

class PlotNet3_2:

    def __init__(self, n_theta, mins, maxs, n_subdivs, n_int_subdivs, exp, save_folder):
        self.n_theta = n_theta
        self.dim = 3
        self.maxs = maxs
        self.mins = mins
        self.n_subdivs = n_subdivs
        self.n_int_subdivs = n_int_subdivs
        self.save_folder = save_folder
        self.dtype = DTYPE
        self.exp = exp
    
    @ut.timer
    def heatmap(self, k, tag):
        i, j = set(range(3)) - {k}
        x = np.linspace(self.mins[i], self.maxs[i], num=self.n_subdivs).astype(self.dtype)
        y = np.linspace(self.mins[j], self.maxs[j], num=self.n_subdivs).astype(self.dtype)
        z = np.linspace(self.mins[k], self.maxs[k], num=self.n_int_subdivs+1).astype(self.dtype)
        
        z = z.reshape(-1, 1)

        p = np.zeros((self.n_subdivs, self.n_subdivs))
        one = tf.ones_like(z)
        
        w = np.array([2. if l%2==0 else 4. for l in range(self.n_int_subdivs+1)])
        w[0], w[-1] = 1., 1.
        for l in range(self.n_subdivs):
            for m in range(self.n_subdivs):
                args = [e for _, e in sorted(zip([i, j, k], [x[l]*one, y[m]*one, z]))]
                if self.exp:
                    p[l, m] = (tf.exp(self.n_theta(*args)).numpy().flatten() * w).sum()
                else:
                    p[l, m] = (self.n_theta(*args).numpy().flatten() * w).sum()


        p /= np.sum(p)
        grid = (self.n_subdivs, self.n_subdivs)
        x, y = np.meshgrid(x, y)
        # x = x.reshape(grid)
        # y = y.reshape(grid)
        # p = p.reshape(grid)

        fig = plt.figure(figsize=(8, 8))
        ax = fig.add_subplot(111)
        im = ax.pcolormesh(x, y, p, cmap='inferno', shading='auto')
        ax.set_xlabel(r'$x_{}$'.format(i))
        ax.set_ylabel(r'$x_{}$'.format(j))
        ax.set_title(r'learned $p(x_{}, x_{})$'.format(i, j))
        fig.colorbar(im)
        plt.savefig('{}/{}_{}_{}.png'.format(self.save_folder, tag, i, j))
      

    @ut.timer
    def plot_all(self, tag):
        for k in range(self.dim):
            self.heatmap(k, tag)



